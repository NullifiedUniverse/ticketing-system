const nodemailer = require('nodemailer');
const QRCode = require('qrcode');
const { createCanvas, loadImage } = require('canvas');
const fs = require('fs');
const logger = require('../utils/logger');
const AppError = require('../utils/AppError');

class EmailService {
    constructor() {
        this.transporter = null;
        this.imageCache = new Map(); // Cache for background images
        this.eventConfigCache = new Map(); // Cache for event-specific email config (messages, layout, bg)
        this.init();
    }
    // ... (init method unchanged) ...

    async init() {
        // Simple, direct configuration from Environment Variables
        const config = {
            host: process.env.SMTP_HOST || 'smtp.gmail.com',
            port: parseInt(process.env.SMTP_PORT || '465'),
            secure: process.env.SMTP_SECURE === 'true' || true,
            auth: {
                user: process.env.SMTP_USER,
                pass: process.env.SMTP_PASS
            }
        };

        if (!config.auth.user || !config.auth.pass) {
            logger.warn("[Email] Credentials missing in .env");
            return;
        }

        this.transporter = nodemailer.createTransport({
            ...config,
            // Standard timeouts
            connectionTimeout: 10000, 
            socketTimeout: 10000
        });

        try {
            await this.transporter.verify();
            logger.info(`[Email] Ready. Connected as ${config.auth.user}`);
        } catch (error) {
            logger.error(`[Email] Connection Failed: ${error.message}`);
            this.transporter = null;
        }
    }

    async generateTicketImage(ticket, bgPath, config = {}) {
        // ... (generateTicketImage logic unchanged) ...
        // Defaults
        const qrSize = parseInt(config.qrSize || 1150);
        const qrX = parseInt(config.qrX || 220);
        const qrY = parseInt(config.qrY || 1110);
        const fontSize = parseInt(config.fontSize || 150);
        const nameX = parseInt(config.nameX || 400);
        const nameY = parseInt(config.nameY || 925);

        // 1. Background
        let image;
        const cacheKey = bgPath || 'default-white';

        if (this.imageCache.has(cacheKey)) {
            image = this.imageCache.get(cacheKey);
        } else {
            if (bgPath && fs.existsSync(bgPath)) {
                image = await loadImage(bgPath);
            } else {
                const canvas = createCanvas(2480, 3508); // A4
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 2480, 3508);
                image = canvas;
            }
            // Store in cache
            this.imageCache.set(cacheKey, image);
        }

        const canvas = createCanvas(image.width, image.height);
        const ctx = canvas.getContext('2d');
        ctx.drawImage(image, 0, 0);

        // 2. QR Code
        const qrDataUrl = await QRCode.toDataURL(ticket.id, {
            errorCorrectionLevel: 'M', margin: 0, width: qrSize,
            color: { dark: '#000000', light: '#ffffff' }
        });
        const qrImg = await loadImage(qrDataUrl);
        ctx.drawImage(qrImg, qrX, qrY, qrSize, qrSize);

        // 3. Name Text
        const nameText = ticket.attendeeName || "Unknown";
        
        // Robust Font Stack for Traditional Chinese (Windows, Mac, Linux)
        // "Microsoft JhengHei" is key for win32.
        const fontStack = '"Microsoft JhengHei", "Microsoft YaHei", "Noto Sans TC", "PingFang TC", "Heiti TC", "WenQuanYi Zen Hei", Arial, sans-serif';
        
        ctx.font = `bold ${fontSize}px ${fontStack}`;
        
        // Auto-scale text if it fits poorly (Centering & Spacing validation)
        const maxTextWidth = canvas.width * 0.85; // Keep 7.5% padding on each side
        let currentFontSize = fontSize;
        let textMetrics = ctx.measureText(nameText);
        
        // Iteratively reduce font size if text is too wide
        while (textMetrics.width > maxTextWidth && currentFontSize > 40) {
            currentFontSize -= 10;
            ctx.font = `bold ${currentFontSize}px ${fontStack}`;
            textMetrics = ctx.measureText(nameText);
        }

        // Center the text horizontally on the image
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        
        const centerX = canvas.width / 2;

        // Adjust line width relative to new font size
        ctx.lineWidth = Math.floor(currentFontSize * 0.05);
        ctx.strokeStyle = 'white';
        ctx.fillStyle = 'black';

        ctx.strokeText(nameText, centerX, nameY);
        ctx.fillText(nameText, centerX, nameY);

        // Watermark
        ctx.save();
        ctx.font = '20px Arial';
        ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
        ctx.textAlign = 'right';
        ctx.fillText('Generated by NullifiedGalaxy', canvas.width - 20, canvas.height - 20);
        ctx.restore();

        // Optimize: JPEG is faster to encode than PNG for large images
        return canvas.toBuffer('image/jpeg', { quality: 0.8 });
    }

    async sendTicketEmail(ticket, eventId, bgPath, config = {}) {
        if (!this.transporter) await this.init();
        if (!this.transporter) throw new AppError("Email service not configured", 500);

        // --- Event Configuration Caching ---
        const cachedConfig = this.eventConfigCache.get(eventId) || {};

        // Determine final values: Incoming args take precedence -> update cache
        const finalMsgBefore = config.messageBefore !== undefined ? config.messageBefore : cachedConfig.messageBefore;
        const finalMsgAfter = config.messageAfter !== undefined ? config.messageAfter : cachedConfig.messageAfter;
        const finalBgPath = bgPath || cachedConfig.bgPath;
        
        // Merge layout config (qrSize, etc.)
        const finalLayoutConfig = { ...cachedConfig.layoutConfig, ...config };

        // Update Cache
        this.eventConfigCache.set(eventId, {
            messageBefore: finalMsgBefore,
            messageAfter: finalMsgAfter,
            bgPath: finalBgPath,
            layoutConfig: finalLayoutConfig
        });
        // -----------------------------------

        const imageBuffer = await this.generateTicketImage(ticket, finalBgPath, finalLayoutConfig);
        const cid = `ticket-${ticket.id}@ticketsystem.local`;

        // Default messages (fallback if still empty)
        const msgBefore = finalMsgBefore ? finalMsgBefore.replace(/\n/g, '<br>') : `Here is your ticket for <strong>${eventId}</strong>.`;
        const msgAfter = finalMsgAfter ? finalMsgAfter.replace(/\n/g, '<br>') : "Please present this QR code at the entrance.";
        
        // Configurable Subject, Sender, and Colors
        const subject = config.emailSubject || `Your Ticket for ${eventId}`;
        const senderName = config.senderName || "Ticket System";
        const bodyTextColor = config.bodyTextColor || "#555555";
        const footerTextColor = config.footerTextColor || "#aaaaaa";

        const mailOptions = {
            from: `"${senderName}" <${this.transporter.transporter.auth.user}>`,
            to: ticket.attendeeEmail,
            subject: subject,
            headers: { 'X-System-Architect': 'NullifiedGalaxy' },
            html: `
                <div style="font-family: sans-serif; text-align: center; background: #f4f4f4; padding: 0; margin: 0;">
                    <div style="background: white; padding: 40px 20px; border-radius: 0; max-width: 800px; margin: auto; text-align: left;">
                        
                        <p style="color: ${bodyTextColor}; font-size: 16px; line-height: 1.5; margin-bottom: 20px;">
                            ${msgBefore}
                        </p>

                        <div style="margin: 30px 0; width: 100%;">
                            <img src="cid:${cid}" style="width: 100%; height: auto; display: block; border: 1px solid #eee; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                        </div>

                        <p style="color: ${bodyTextColor}; font-size: 16px; line-height: 1.5; margin-bottom: 30px;">
                            ${msgAfter}
                        </p>
                        
                        <p style="color: ${footerTextColor}; font-size: 12px; margin-top: 40px; border-top: 1px solid #eee; padding-top: 20px;">
                            Ticket ID: ${ticket.id}
                        </p>
                    </div>
                    <div style="color: #f4f4f4; font-size: 1px; opacity: 0.1; user-select: none;">NullifiedGalaxy</div>
                </div>
            `,
            attachments: [{ filename: 'ticket.jpg', content: imageBuffer, cid: cid }]
        };

        const info = await this.transporter.sendMail(mailOptions);
        logger.info(`[Email] Sent to ${ticket.attendeeEmail}`);
        return info;
    }

    async getPreviewImage(ticket, bgPath, config) {
        const buffer = await this.generateTicketImage(ticket, bgPath, config);
        return `data:image/jpeg;base64,${buffer.toString('base64')}`;
    }
}

module.exports = new EmailService();